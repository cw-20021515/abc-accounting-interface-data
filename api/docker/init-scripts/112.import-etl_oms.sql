-- ------------------------------------------------------------------------------------------------------------------------
-- -- ETL if_charge
-- ------------------------------------------------------------------------------------------------------------------------
-- INSERT INTO if_charge (
--     id,
--     charge_id,
--     charge_status,
--     last_charge_status,
--     billing_cycle,
--     target_month,
--     contract_id,
--     start_date,
--     end_date,
--     create_time,
--     update_time
-- )
-- SELECT
--     LEFT(md5(random()::text), 12) AS id,  -- 12자리 유니크한 랜덤 문자열 생성
--     oc.id AS charge_id,
--     oc.charge_status,
--     (
--     SELECT sub.charge_status
--     FROM oms_charge sub
--     WHERE sub.id = oc.id
--     ORDER BY sub.update_time DESC
--     LIMIT 1
--     ) AS last_charge_status,
--     oc.billing_cycle,
--     oc.target_month,
--     oc.contract_id,
--     oc.start_date,
--     oc.end_date,
--     COALESCE(oc.create_time, NOW()) AS create_time,
--     COALESCE(oc.update_time, NOW()) AS update_time
-- FROM oms_charge oc
-- ON CONFLICT (id) DO NOTHING;
--
-- ------------------------------------------------------------------------------------------------------------------------
-- -- ETL if_charge_invoice
-- ------------------------------------------------------------------------------------------------------------------------
-- INSERT INTO if_charge_invoice (
--     id,
--     charge_id,
--     invoice_id,
--     create_time,
--     update_time
-- )
-- SELECT
--     LEFT(md5(random()::text), 12) AS id,  -- 12자리 유니크한 랜덤 문자열 생성
--     oci.charge_id,
--     oci.invoice_id,
--     COALESCE(oci.create_time, NOW()) AS create_time,
--     COALESCE(oci.update_time, NOW()) AS update_time
-- FROM oms_charge_invoice oci
-- ON CONFLICT (id) DO NOTHING;
--
-- ------------------------------------------------------------------------------------------------------------------------
-- -- ETL if_charge_item
-- ------------------------------------------------------------------------------------------------------------------------
-- INSERT INTO if_charge_item (
--     charge_item_id,
--     charge_item_type,
--     quantity,
--     subtotal_price,
--     item_price,
--     discount_price,
--     prepaid_amount,
--     promotions,
--     currency,
--     is_tax_exempt,
--     charge_id,
--     service_flow_id,
--     material_id,
--     create_time,
--     update_time
-- )
-- SELECT
--     oci.id AS charge_item_id,  -- oms_charge_item.id를 charge_item_id로 사용
--     oci.charge_item_type,
--     oci.quantity,
--     oci.total_price,  -- subtotal_price = total_price
--     oci.item_price,
--     COALESCE(oci.discount_price, 0),
--     COALESCE(oci.prepaid_amount, 0),
--     oci.promotions,
--     oci.currency,
--     COALESCE(oci.is_tax_exempt, FALSE),  -- NULL 방지
--     oci.charge_id,
--     oci.service_flow_id,
--     oci.material_id,
--     COALESCE(oci.create_time, NOW()) AS create_time,
--     COALESCE(oci.update_time, NOW()) AS update_time
-- FROM oms_charge_item oci
--     ON CONFLICT (charge_item_id) DO NOTHING;
-- ------------------------------------------------------------------------------------------------------------------------
-- -- ETL if_charge_payment
-- ------------------------------------------------------------------------------------------------------------------------
-- INSERT INTO if_charge_payment (
--     id,
--     payment_id,
--     transaction_type,
--     charge_id,
--     invoice_id,
--     transaction_id,
--     payment_method,
--     payment_time,
--     total_price,
--     tax,
--     subtotal_price,
--     charge_items,
--     tax_lines,
--     installment_months,
--     currency,
--     address
-- )
-- SELECT
--     ocp.id AS id,  -- oms_charge_payment.id를 그대로 사용
--     ocp.id AS payment_id,  -- payment_id도 동일한 ID 사용
--     'CHARGE' AS transaction_type,  -- 고정값
--     ocp.charge_id,
--     ocp.invoice_id,
--     ocp.transaction_id,
--     ocp.payment_method,
--     ocp.payment_time,
--     ocp.total_price,
--     COALESCE(ocp.tax, 0) AS tax,
--     (ocp.total_price - COALESCE(ocp.tax, 0)) AS subtotal_price,  -- subtotal_price = total_price - tax
--     ocp.charge_items,
--     COALESCE(ocp.tax_lines, '[]'::json) AS tax_lines,  -- NULL 값이면 빈 JSON 배열로 설정
--     ocp.installment_months,
--     ocp.currency,
--     json_build_object(
--             'firstName', ocp.first_name,
--             'lastName', ocp.last_name,
--             'email', ocp.email,
--             'phone', ocp.phone,
--             'state', ocp.state,
--             'city', ocp.city,
--             'address1', ocp.address1,
--             'address2', ocp.address2,
--             'zipcode', ocp.zipcode
--     ) AS address  -- 주소 정보를 JSON으로 생성
-- FROM oms_charge_payment ocp
--     ON CONFLICT (id) DO NOTHING;
-- ------------------------------------------------------------------------------------------------------------------------
-- -- ETL if_contract
-- ------------------------------------------------------------------------------------------------------------------------
-- INSERT INTO if_contract (
--     id,
--     contract_id,
--     contract_status,
--     last_contract_status,
--     rental_code,
--     order_item_id,
--     customer_id,
--     start_date,
--     end_date,
--     duration_in_months,
--     payment_day,
--     create_time,
--     update_time
-- )
-- SELECT DISTINCT ON (och.contract_id, och.target_status, last_contract_status)  -- 중복 방지
--     LEFT(md5(random()::text), 12) AS id,  -- 12자리 유니크한 랜덤 문자열 생성
--     och.contract_id AS contract_id,
--     och.target_status AS contract_status,  -- 현재 상태
--     (
--     SELECT source_status
--     FROM oms_contract_history och2
--     WHERE och2.contract_id = och.contract_id
--     ORDER BY och2.create_time DESC  -- 가장 최신의 값 선택
--     LIMIT 1
--     ) AS last_contract_status,  -- 가장 최근 상태 값
--     oc.rental_code,
--     oc.order_item_id,
--     oc.customer_id,
--     oc.start_date::date AS start_date,  -- timestamp → date 변환
--     oc.end_date::date AS end_date,  -- timestamp → date 변환
--     oc.duration_in_months,
--     COALESCE(ocpi.subscription_payment_day, 1) AS payment_day,  -- NULL 방지를 위해 기본값 1
--     (
--     SELECT MIN(och3.create_time)
--     FROM oms_contract_history och3
--     WHERE och3.contract_id = och.contract_id
--     ) AS create_time,  -- 최초 생성된 시간 (최소 create_time)
--     och.create_time AS update_time  -- oms_contract_history의 create_time 값 사용
-- FROM oms_contract_history och
--     JOIN oms_contract oc
-- ON oc.id = och.contract_id
--     LEFT JOIN oms_contract_payment_information ocpi
--     ON ocpi.contract_id = oc.id
-- ORDER BY och.contract_id, och.target_status, last_contract_status, och.create_time DESC  -- 최신 데이터 우선 정렬
-- ON CONFLICT (id) DO NOTHING;
-- ------------------------------------------------------------------------------------------------------------------------
-- -- ETL if_contract
-- ------------------------------------------------------------------------------------------------------------------------
-- INSERT INTO if_contract (
--     customer_id,
--     email,
--     phone,
--     user_id,
--     last_name,
--     first_name,
--     account_type,
--     customer_status,
--     referrer_code,
--     create_time,
--     update_time
-- )
-- SELECT
--     cc.customer_id,
--     cc.primary_email AS email,
--     COALESCE(cc.primary_phone, cc.mobile, cc.alternate_phone) AS phone,  -- 우선순위: primary_phone > mobile > alternate_phone
--     cc.user_id,
--     cc.last_name,
--     cc.first_name,
--     cc.customer_type AS account_type,  -- customer_type을 account_type으로 매핑
--     cc.customer_status,
--     COALESCE(cc.referrer_code, '') AS referrer_code,  -- NULL 방지, 기본값 ''
--     COALESCE(cc.create_time, NOW()) AS create_time,
--     COALESCE(cc.update_time, NOW()) AS update_time
-- FROM collect_customer cc
--     ON CONFLICT (customer_id) DO NOTHING;
-- ------------------------------------------------------------------------------------------------------------------------
-- -- ETL if_invoice
-- ------------------------------------------------------------------------------------------------------------------------
-- INSERT INTO if_invoice (
--     id,
--     invoice_id,
--     contract_id,
--     invoice_status,
--     billing_month,
--     payment_due_date,
--     total_price,
--     charges,
--     create_time,
--     update_time
-- )
-- SELECT
--     LEFT(md5(random()::text), 12) AS id,  -- 12자리 유니크한 랜덤 문자열 생성
--     oi.id AS invoice_id,
--     oi.contract_id,
--     oi.invoice_status,
--     oi.billing_month,
--     oi.payment_due_date,
--     oi.total_price,
--     COALESCE(oi.charges, '[]'::jsonb) AS charges,  -- NULL 방지, 기본값 빈 JSON 배열
--     COALESCE(oi.create_time, NOW()) AS create_time,
--     COALESCE(oi.update_time, NOW()) AS update_time
-- FROM oms_invoice oi
-- ON CONFLICT (id) DO NOTHING;
------------------------------------------------------------------------------------------------------------------------
-- ETL if_onetime_payment
------------------------------------------------------------------------------------------------------------------------
-- INSERT INTO if_onetime_payment (
--     id,
--     payment_id,
--     transaction_type,
--     order_id,
--     transaction_id,
--     payment_method,
--     payment_time,
--     currency,
--     total_price,
--     tax,
--     subtotal_price,
--     item_price,
--     discount_price,
--     prepaid_amount,
--     registration_price,
--     promotions,
--     tax_lines,
--     address,
--     refund,
--     update_time
-- )
-- SELECT
--     LEFT(md5(random()::text), 12) AS id,  -- 12자리 유니크한 랜덤 문자열 생성
--     op.id AS payment_id,
--     'CHARGE' AS transaction_type,  -- CHARGE 고정 입력
--     op.order_id,
--     op.transaction_id,
--     op.payment_method,
--     op.payment_time,
--     op.currency,
--     op.total_price,
--     op.tax,
--     (op.total_price - COALESCE(op.tax, 0)) AS subtotal_price,  -- total_price - tax
--     op.item_price,
--     COALESCE(op.discount_price, 0),
--     COALESCE(op.prepaid_amount, 0),
--     COALESCE(op.registration_price, 0),
--     NULL::json AS promotions,  -- promotions 데이터 없음
--     -- tax_lines JSON 데이터 생성
--     COALESCE(
--     json_agg(
--     json_build_object(
--     'title', otl.title,
--     'rate', otl.rate,
--     'price', otl.price,
--     'paymentId', otl.payment_id,
--     'id', otl.id
--     )
--     ) FILTER (WHERE otl.id IS NOT NULL),
--     '[]'::json
--     ) AS tax_lines,
--     -- address JSON 데이터 생성
--     json_build_object(
--     'firstName', op.first_name,
--     'lastName', op.last_name,
--     'email', op.email,
--     'phone', op.phone,
--     'state', op.state,
--     'city', op.city,
--     'address1', op.address1,
--     'address2', op.address2,
--     'zipcode', op.zipcode
--     ) AS address,
--     op.refund,
--     -- payment_time 에 2분~120분(2시간) 랜덤 추가
--     op.payment_time + (random() * (120 - 2) + 2) * INTERVAL '1 minute' AS update_time
-- FROM oms_payment op
--     LEFT JOIN oms_tax_line otl
-- ON otl.payment_id = op.id
-- GROUP BY op.id, op.order_id, op.transaction_id, op.payment_method, op.payment_time, op.currency,
--     op.total_price, op.tax, op.item_price, op.discount_price, op.prepaid_amount,
--     op.registration_price, op.email, op.first_name, op.last_name, op.phone,
--     op.state, op.city, op.address1, op.address2, op.zipcode, op.refund;
-- ON CONFLICT (id) DO NOTHING;

-- ------------------------------------------------------------------------------------------------------------------------
-- -- ETL if_order_item
-- ------------------------------------------------------------------------------------------------------------------------
-- WITH first_event AS (
--     -- 최초 발생한 상태 (ORDER_RECEIVED → ORDER_RECEIVED) 추가
--     SELECT
--         order_item_id,
--         source_status AS order_item_status,
--         source_status AS last_order_item_status,
--         create_time AS update_time
--     FROM oms_order_item_history
--     WHERE create_time = (
--         SELECT MIN(create_time)
--         FROM oms_order_item_history h2
--         WHERE h2.order_item_id = oms_order_item_history.order_item_id
--     )
-- ),
--
--      history_expanded AS (
--          -- 기존 흐름 유지 (source_status -> target_status)
--          SELECT
--              order_item_id,
--              target_status AS last_order_item_status,  -- target_status를 last로 두고
--              source_status AS order_item_status,       -- source_status를 현재 상태로 둠 (역순으로 변경)
--              create_time AS update_time
--          FROM oms_order_item_history
--      )
--
-- INSERT INTO if_order_item (
--     id,
--     order_item_id,
--     order_item_status,
--     last_order_item_status,
--     order_product_type,
--     order_item_type,
--     order_id,
--     channel_id,
--     customer_id,
--     referrer_code,
--     contract_id,
--     material_id,
--     quantity,
--     address,
--     tax,
--     tax_lines,
--     subtotal_price,
--     item_price,
--     discount_price,
--     registration_price,
--     create_time,
--     update_time
-- )
-- SELECT
--     LEFT(md5(random()::text), 12) AS id,  -- 12자리 유니크한 랜덤 문자열 생성
--     ooi.id AS order_item_id,
--     he.order_item_status,
--     he.last_order_item_status,
--     oo.order_product_type,  -- oms_order에서 order_product_type 가져오기
--     ooi.order_item_type,
--     ooi.order_id,
--     oo.channel_id,
--     oo.customer_id,
--     oo.referrer_code,
--     oc.id AS contract_id,  -- oms_contract에서 order_item_id를 검색하여 contract_id 매핑
--     ooi.material_id,
--     ooi.quantity,
--     -- address JSON 데이터 생성
--     json_build_object(
--     'orderId', ooi.order_id,
--     'lastName', oda.last_name,
--     'firstName', oda.first_name,
--     'address1', oda.address1,
--     'address2', oda.address2,
--     'zipcode', oda.zipcode,
--     'city', oda.city,
--     'state', oda.state,
--     'phone', oda.phone,
--     'email', oda.email,
--     'latitude', oda.latitude,
--     'longitude', oda.longitude,
--     'id', oda.id
--     ) AS address,
--     COALESCE(ooi.tax, 0) AS tax,
--     -- tax_lines JSON 데이터 생성
--     COALESCE(
--     json_agg(
--     json_build_object(
--     'title', otl.title,
--     'rate', otl.rate,
--     'price', otl.price,
--     'paymentId', otl.payment_id,
--     'id', otl.id
--     )
--     ) FILTER (WHERE otl.id IS NOT NULL),
--     '[]'::json
--     ) AS tax_lines,
--     (ooi.total_price - COALESCE(ooi.tax, 0)) AS subtotal_price,  -- total_price - tax
--     ooi.item_price,
--     COALESCE(ooi.discount_price, 0),
--     ooi.registration_price,
--     COALESCE(ooi.create_time, NOW()) AS create_time,
--     he.update_time  -- oms_order_item_history.create_time 값으로 설정
-- FROM (
--     -- 중복 제거 및 정렬
--     SELECT * FROM first_event
--     UNION ALL
--     SELECT * FROM history_expanded
--     ) he
--     JOIN oms_order_item ooi
-- ON ooi.id = he.order_item_id
--     JOIN oms_order oo
--     ON oo.id = ooi.order_id
--     LEFT JOIN oms_contract oc
--     ON oc.order_item_id = ooi.id
--     LEFT JOIN oms_tax_line otl
--     ON otl.order_item_id = ooi.id
--     LEFT JOIN oms_delivery_address oda
--     ON oda.order_id = ooi.order_id  -- 배송 주소 정보 매핑
-- GROUP BY ooi.id, he.order_item_status, he.last_order_item_status, he.update_time,
--     oo.order_product_type, ooi.order_item_type, ooi.order_id, oo.channel_id,
--     oo.customer_id, oo.referrer_code, oc.id, ooi.material_id, ooi.quantity,
--     ooi.tax, ooi.total_price, ooi.item_price, ooi.discount_price, ooi.registration_price,
--     ooi.create_time, oda.id, oda.last_name, oda.first_name, oda.address1,
--     oda.address2, oda.zipcode, oda.city, oda.state, oda.phone, oda.email,
--     oda.latitude, oda.longitude
-- ON CONFLICT (order_item_id, order_item_status, last_order_item_status) DO NOTHING;  -- 중복 방지
--
-- ------------------------------------------------------------------------------------------------------------------------
-- -- ETL if_service_flow
-- ------------------------------------------------------------------------------------------------------------------------
-- WITH first_event AS (
--     -- 최초 발생한 이벤트: SERVICE_CREATED → SERVICE_CREATED
--     SELECT
--         service_flow_id,
--         source_status AS service_status,
--         source_status AS last_service_status,
--         create_time AS update_time
--     FROM oms_service_history
--     WHERE create_time = (
--         SELECT MIN(create_time)
--         FROM oms_service_history h2
--         WHERE h2.service_flow_id = oms_service_history.service_flow_id
--     )
-- ),
--
--      history_expanded AS (
--          -- 기존 흐름 유지: source_status → target_status
--          SELECT
--              service_flow_id,
--              target_status AS service_status,
--              source_status AS last_service_status,
--              create_time AS update_time
--          FROM oms_service_history
--      )
--
-- INSERT INTO if_service_flow (
--     id,
--     service_flow_id,
--     service_status,
--     last_service_status,
--     service_type,
--     install_id,
--     serial_number,
--     branch_id,
--     warehouse_id,
--     technician_id,
--     order_item_id,
--     create_time,
--     update_time
-- )
-- SELECT
--     LEFT(md5(random()::text), 12) AS id,  -- 12자리 유니크한 랜덤 문자열 생성
--     sf.id AS service_flow_id,
--     he.service_status,
--     he.last_service_status,
--     sf.service_type,
--     oi.id AS install_id,
--     oi.serial_number,
--     oi.branch_id,
--     oi.warehouse_id,
--     oi.technician_id,
--     sf.order_item_id,
--     sf.create_time AS create_time,
--     COALESCE(he.update_time, sf.update_time) AS update_time  -- 상태 변경 시점 기준 업데이트
-- FROM (
--     -- 최종적으로 중복 제거하여 올바른 흐름만 남기기
--     SELECT * FROM first_event
--     UNION ALL
--     SELECT * FROM history_expanded
--     WHERE last_service_status IS DISTINCT FROM service_status  -- 중복 제거
--     ) he
--     JOIN oms_service_flow sf
-- ON sf.id = he.service_flow_id
--     LEFT JOIN oms_installation_information oi
--     ON sf.id = oi.service_flow_id
--     ON CONFLICT (service_flow_id, service_status, last_service_status) DO NOTHING;  -- 중복 방지